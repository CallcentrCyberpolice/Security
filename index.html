<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Навігатор Приміщень v3</title>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        :root {
            --bg-color: #f4f7f6;
            --panel-bg: #ffffff;
            --primary-color: #4a90e2; /* Blue */
            --secondary-color: #50e3c2; /* Teal */
            --accent-color: #f5a623; /* Orange */
            --text-color: #333;
            --text-light: #777;
            --error-color: #d0021b;
            --success-color: #7ed321;
            --disabled-bg: #e0e0e0;
            --disabled-text: #9e9e9e;
            --border-color: #ddd;
            --map-bg: #e9eef2;
            --room-fill: rgba(74, 144, 226, 0.1);
            --room-border: var(--primary-color);
            --current-room-fill: rgba(80, 227, 194, 0.2);
            --current-room-border: var(--secondary-color);
            --arrow-color: var(--error-color);
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        html, body {
            margin: 0; padding: 0;
            height: 100%; width: 100%;
            overflow: hidden;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            -webkit-user-select: none; user-select: none;
            touch-action: manipulation;
            font-size: 16px; /* Base font size */
        }

        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        /* --- Top Panel --- */
        #top-panel {
            background: var(--panel-bg);
            padding: 10px 15px;
            box-shadow: 0 2px 5px var(--shadow-color);
            z-index: 10;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; /* Prevent shrinking */
        }

        #status-bar {
            font-size: 0.9em;
            min-height: 20px;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 500;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
        }
        #status-bar.error { background-color: var(--error-color); color: white; border-color: var(--error-color);}
        #status-bar.success { background-color: var(--success-color); color: white; border-color: var(--success-color);}
        #status-bar.info { background-color: var(--primary-color); color: white; border-color: var(--primary-color);}

        .control-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        button {
            padding: 10px 15px;
            background-color: var(--primary-color);
            border: none;
            color: white;
            font-size: 0.9em;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px; /* Space between icon and text */
        }
        button i { font-size: 1.1em; } /* Slightly larger icons */

        button:hover:not(:disabled) { background-color: #3a7ac0; }
        button:active:not(:disabled) { transform: scale(0.98); }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            cursor: not-allowed;
        }
        button.secondary { background-color: var(--secondary-color); }
        button.secondary:hover:not(:disabled) { background-color: #40c0a0; }
        button.danger { background-color: var(--error-color); }
        button.danger:hover:not(:disabled) { background-color: #a00010; }

        /* --- Main Content Area --- */
        #main-content {
            flex-grow: 1;
            position: relative;
            display: flex; /* Use flex for canvas centering */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Important for canvas panning/zooming later */
             background-color: var(--map-bg);
        }

        #map-canvas {
            display: block;
            background-color: var(--panel-bg); /* White background for the map */
            /* Max size will be controlled by JS/container */
            box-shadow: 0 0 15px rgba(0,0,0,0.15);
            cursor: grab; /* Indicate panning possibility */
            border: 1px solid var(--border-color);
        }
         #map-canvas.grabbing { cursor: grabbing; }
         #map-canvas.placing { cursor: crosshair; }

        /* --- User Arrow --- */
        #user-arrow {
            width: 0; height: 0;
            border-left: 9px solid transparent;
            border-right: 9px solid transparent;
            border-bottom: 18px solid var(--arrow-color);
            position: absolute; /* Positioned relative to main-content */
            transform-origin: center bottom;
            transition: transform 0.1s linear;
            z-index: 5;
            pointer-events: none; /* Don't interfere with map interaction */
            display: none; /* Hidden initially */
            filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.3));
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 15px;
             box-sizing: border-box;
        }
        .modal-overlay.active { display: flex; }

        .modal-content {
            background: var(--panel-bg);
            padding: 25px 30px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        .modal-content h3 { margin-top: 0; color: var(--primary-color); }
        .modal-content p { color: var(--text-light); line-height: 1.5; margin-bottom: 20px;}
        .modal-content label { display: block; margin-bottom: 8px; text-align: left; font-weight: bold;}
        .modal-content input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 1em;
            box-sizing: border-box;
        }
        .modal-buttons { display: flex; gap: 10px; justify-content: center; }

        /* --- Room List (Optional Panel) --- */
        #room-list-panel {
            position: absolute;
            top: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 3px var(--shadow-color);
            z-index: 5;
            max-height: 200px;
            overflow-y: auto;
        }
         #room-list-panel h4 { margin: 0 0 5px 0; font-size: 0.9em; }
         #room-list-panel ul { list-style: none; padding: 0; margin: 0; }
         #room-list-panel li { padding: 5px; cursor: pointer; font-size: 0.85em; border-bottom: 1px solid #eee;}
         #room-list-panel li:hover { background-color: #eee; }
         #room-list-panel li.active-tracking-room { font-weight: bold; background-color: var(--secondary-color); color: white; }


    </style>
</head>
<body>

<div id="app-container">

    <!-- Top Control Panel -->
    <div id="top-panel">
        <div id="status-bar">Завантаження...</div>
        <div class="control-group">
            <!-- Initial State -->
            <button id="btn-request-perms" title="Запросити дозволи на сенсори"><i class="fas fa-user-lock"></i> Дозволи</button>
            <!-- Room Definition -->
            <button id="btn-add-room" title="Почати визначення нової кімнати" disabled><i class="fas fa-plus-square"></i> Додати кімнату</button>
            <button id="btn-set-corner1" title="Встановити перший кут поточної кімнати" disabled class="secondary"><i class="fas fa-map-marker-alt"></i> Кут 1</button>
            <button id="btn-set-corner2" title="Встановити другий кут поточної кімнати" disabled class="secondary"><i class="fas fa-map-marker-alt"></i> Кут 2</button>
            <button id="btn-cancel-define" title="Скасувати визначення кімнати" disabled class="danger"><i class="fas fa-times"></i> Скасувати</button>
            <!-- Tracking -->
            <button id="btn-start-tracking" title="Почати відстеження руху" disabled><i class="fas fa-play"></i> Відстеження</button>
            <button id="btn-stop-tracking" title="Зупинити відстеження руху" disabled class="danger"><i class="fas fa-stop"></i> Стоп</button>
             <!-- Map Interaction (Could add zoom etc.) -->
        </div>
    </div>

    <!-- Main Map Area -->
    <div id="main-content">
        <canvas id="map-canvas"></canvas>
        <div id="user-arrow"></div>
         <!-- Optional Room List -->
         <div id="room-list-panel" style="display: none;">
             <h4>Кімнати:</h4>
             <ul id="room-list"></ul>
         </div>
    </div>

</div>

<!-- Modals -->
<div id="modal-permissions" class="modal-overlay">
    <div class="modal-content">
        <h3><i class="fas fa-user-shield"></i> Потрібні дозволи</h3>
        <p>Для роботи навігації сайту потрібен доступ до сенсорів руху (акселерометр) та орієнтації (компас) вашого пристрою. Будь ласка, надайте дозвіл.</p>
        <div class="modal-buttons">
            <button id="btn-grant-perms" class="secondary"><i class="fas fa-check"></i> Надати дозвіл</button>
            <button id="btn-deny-perms" class="danger"><i class="fas fa-times"></i> Відхилити</button>
        </div>
    </div>
</div>

<div id="modal-calibration" class="modal-overlay">
    <div class="modal-content">
        <h3><i class="fas fa-compass"></i> Калібрування Компаса</h3>
        <p>Для кращої точності напрямку, будь ласка, відкалібруйте компас. Повільно покрутіть телефон у всіх напрямках (рухом "вісімка").</p>
        <div class="modal-buttons">
            <button id="btn-calibration-done" class="secondary"><i class="fas fa-check"></i> Готово!</button>
        </div>
    </div>
</div>

<div id="modal-room-name" class="modal-overlay">
    <div class="modal-content">
        <h3><i class="fas fa-edit"></i> Назва нової кімнати</h3>
        <label for="input-room-name">Введіть назву кімнати:</label>
        <input type="text" id="input-room-name" placeholder="Наприклад: Вітальня, Кухня...">
        <div class="modal-buttons">
            <button id="btn-confirm-room-name" class="secondary"><i class="fas fa-check"></i> Далі</button>
            <button id="btn-cancel-room-name" class="danger"><i class="fas fa-times"></i> Скасувати</button>
        </div>
    </div>
</div>

<div id="modal-place-room" class="modal-overlay">
     <div class="modal-content">
         <h3><i class="fas fa-map-marked-alt"></i> Розміщення кімнати</h3>
         <p>Кімната "<span id="placeroom-name"></span>" визначена. Тепер клікніть на карті, щоб розмістити її.</p>
         <p style="font-size: 0.9em; color: var(--text-light);">(Ви зможете перемістити її пізніше, якщо потрібно)</p>
         <!-- Button might not be needed if click on map is the action -->
          <button id="btn-cancel-place-room" class="danger"><i class="fas fa-times"></i> Скасувати розміщення</button>
     </div>
 </div>


<script>
    // --- Application State ---
    let state = 'initializing'; // initializing, no_perms, idle, defining_room_name, defining_corner1, defining_corner2, placing_room, mapping, tracking
    let permissionsGranted = false;
    let needsCalibrationCheck = true;
    let rooms = []; // Array to store room objects { id, name, corners:[{x,y},{x,y}], mapRect:{x,y,w,h}, color }
    let currentRoomDefinition = null; // Temp storage while defining a room { name, corner1: {x,y}, corner2: {x,y} }
    let activeTrackingRoomId = null; // ID of the room the user is currently in
    let userPosition = { x: 0, y: 0 }; // User's position relative to the active room's origin on map
    let userOrientation = 0; // User's orientation (degrees)
    let mapOffset = { x: 0, y: 0 }; // For panning the map
    let isPanning = false;
    let panStart = { x: 0, y: 0 };

    // --- Constants & Config ---
    const SENSOR_FREQUENCY = 60; // Hz
    const STEP_THRESHOLD = 1.6;
    const STEP_COOLDOWN = 390; // ms
    const STEP_SIZE_PIXELS = 10; // ESTIMATED pixels per step on the map (VERY rough)
    const DEFAULT_ROOM_SIZE = { w: 100, h: 120 }; // Default pixels if corner distance too small

    // --- DOM Elements ---
    const statusBar = document.getElementById('status-bar');
    const btnRequestPerms = document.getElementById('btn-request-perms');
    const btnAddRoom = document.getElementById('btn-add-room');
    const btnSetCorner1 = document.getElementById('btn-set-corner1');
    const btnSetCorner2 = document.getElementById('btn-set-corner2');
    const btnCancelDefine = document.getElementById('btn-cancel-define');
    const btnStartTracking = document.getElementById('btn-start-tracking');
    const btnStopTracking = document.getElementById('btn-stop-tracking');
    const mapCanvas = document.getElementById('map-canvas');
    const ctx = mapCanvas.getContext('2d');
    const userArrow = document.getElementById('user-arrow');
    const mainContent = document.getElementById('main-content');
    const roomListPanel = document.getElementById('room-list-panel');
    const roomListUl = document.getElementById('room-list');

    // Modals & Inputs
    const modalPermissions = document.getElementById('modal-permissions');
    const btnGrantPerms = document.getElementById('btn-grant-perms');
    const btnDenyPerms = document.getElementById('btn-deny-perms');
    const modalCalibration = document.getElementById('modal-calibration');
    const btnCalibrationDone = document.getElementById('btn-calibration-done');
    const modalRoomName = document.getElementById('modal-room-name');
    const inputRoomName = document.getElementById('input-room-name');
    const btnConfirmRoomName = document.getElementById('btn-confirm-room-name');
    const btnCancelRoomName = document.getElementById('btn-cancel-room-name');
    const modalPlaceRoom = document.getElementById('modal-place-room');
    const placeRoomNameSpan = document.getElementById('placeroom-name');
     const btnCancelPlaceRoom = document.getElementById('btn-cancel-place-room');


    // --- Sensor Variables ---
    let motionSensor = null;
    let orientationSensor = null;
    let lastAccMagnitude = 0;
    let stepCooldownTimeout = null;
    let stepCounter = 0; // Local counter for tracking session

    // --- Initialization ---
    function init() {
        console.log("App Initializing...");
        setStatus('Перевірка HTTPS та налаштування...', 'info');
        if (!checkHttps()) return;

        setupEventListeners();
        resizeCanvas();
        // Don't request permissions automatically, wait for button press
        setState('no_perms');
        console.log("App Initialized. Waiting for permissions request.");
    }

    function checkHttps() {
        if (window.location.protocol !== 'https:') {
            setStatus('ПОМИЛКА: Потрібен HTTPS! Відкрийте сторінку через https://', true);
            // Disable all buttons except permissions potentially?
            return false;
        }
        return true;
    }

    function setupEventListeners() {
        btnRequestPerms.addEventListener('click', () => showModal('modal-permissions'));
        btnGrantPerms.addEventListener('click', handlePermissionRequest);
        btnDenyPerms.addEventListener('click', handlePermissionDenial);
        btnCalibrationDone.addEventListener('click', handleCalibrationDone);

        btnAddRoom.addEventListener('click', startRoomDefinition);
        btnConfirmRoomName.addEventListener('click', confirmRoomName);
        btnCancelRoomName.addEventListener('click', cancelRoomDefinition);
        btnSetCorner1.addEventListener('click', setCorner1);
        btnSetCorner2.addEventListener('click', setCorner2);
        btnCancelDefine.addEventListener('click', cancelRoomDefinition);
         btnCancelPlaceRoom.addEventListener('click', cancelRoomPlacement);


        btnStartTracking.addEventListener('click', startTracking);
        btnStopTracking.addEventListener('click', stopTracking);

        window.addEventListener('resize', resizeCanvas);

        // Map Interaction (Basic Panning)
        mapCanvas.addEventListener('mousedown', handlePanStart);
        mapCanvas.addEventListener('mousemove', handlePanMove);
        mapCanvas.addEventListener('mouseup', handlePanEnd);
        mapCanvas.addEventListener('mouseleave', handlePanEnd);
         // Map Click for Placing Room
         mapCanvas.addEventListener('click', handleMapClickForPlacement);

         // Room List Interaction
         roomListUl.addEventListener('click', handleRoomListClick);
    }

    // --- State Management ---
    function setState(newState) {
        console.log(`State changing from ${state} to ${newState}`);
        state = newState;
        updateUI();
    }

    function updateUI() {
        // Disable everything by default
        const allButtons = document.querySelectorAll('#top-panel button');
        allButtons.forEach(btn => btn.disabled = true);
        mapCanvas.classList.remove('placing');


        // Enable based on state
        switch (state) {
            case 'no_perms':
                btnRequestPerms.disabled = false;
                setStatus('Натисніть "Дозволи", щоб почати.', 'info');
                break;
            case 'idle':
                btnAddRoom.disabled = false;
                if (rooms.length > 0) btnStartTracking.disabled = false;
                setStatus('Готово. Додайте кімнату або почніть відстеження.');
                break;
            case 'defining_room_name':
                // Modal is active, no buttons needed here
                setStatus('Введіть назву для нової кімнати.');
                break;
            case 'defining_corner1':
                btnSetCorner1.disabled = false;
                btnCancelDefine.disabled = false;
                setStatus(`Кімната "${currentRoomDefinition?.name}": Встаньте в перший кут та натисніть "Кут 1".`);
                break;
            case 'defining_corner2':
                btnSetCorner2.disabled = false;
                btnCancelDefine.disabled = false;
                setStatus(`Кімната "${currentRoomDefinition?.name}": Перейдіть до протилежного кута та натисніть "Кут 2".`);
                break;
            case 'placing_room':
                 // Modal active, potentially allow cancel
                 btnCancelPlaceRoom.disabled = false; // Enable cancel within modal
                 mapCanvas.classList.add('placing');
                 setStatus(`Розмістіть кімнату "${currentRoomDefinition?.name}" на карті кліком.`);
                 break;
            case 'mapping': // General state when viewing/interacting with map but not tracking
                btnAddRoom.disabled = false;
                 if (rooms.length > 0) btnStartTracking.disabled = false;
                 // Add map interaction buttons here later (zoom, drag room)
                setStatus('Карта готова. Можна додати ще кімнату або почати відстеження.');
                break;
            case 'tracking':
                btnStopTracking.disabled = false;
                userArrow.style.display = 'block';
                // Disable adding rooms while tracking
                 setStatus(`Відстеження в кімнаті: ${getRoomById(activeTrackingRoomId)?.name || 'Невідомо'}. Кроків: ${stepCounter}`);
                break;
            case 'initializing':
            case 'error':
                // Status set elsewhere
                break;
        }
         // Update Room List Panel
         roomListPanel.style.display = rooms.length > 0 ? 'block' : 'none';
         updateRoomList();
    }

    function setStatus(message, type = 'normal') { // type: normal, info, success, error
        statusBar.textContent = message;
        statusBar.className = 'status-bar'; // Reset classes
        if (type === 'error') {
            statusBar.classList.add('error');
            console.error("Status (Error):", message);
        } else if (type === 'success') {
            statusBar.classList.add('success');
            console.log("Status (Success):", message);
        } else if (type === 'info') {
            statusBar.classList.add('info');
            console.log("Status (Info):", message);
        } else {
             console.log("Status:", message);
        }
    }

    function showModal(modalId, active = true) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.toggle('active', active);
        }
    }

    // --- Permissions ---
    async function handlePermissionRequest() {
        console.log("Requesting sensor permissions...");
        showModal('modal-permissions', false); // Hide prompt
        setStatus('Запит дозволів...', 'info');

        try {
            let motionGranted = false;
            // Request DeviceMotionEvent permission (primarily for iOS)
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                const motionPermission = await DeviceMotionEvent.requestPermission();
                motionGranted = motionPermission === 'granted';
                 console.log("DeviceMotionEvent permission:", motionPermission);
            } else {
                // Assume granted or not needed if API doesn't exist/require it
                console.log("DeviceMotionEvent.requestPermission not available/needed.");
                motionGranted = true; // Or check if the event listener works later
            }

            let orientationGranted = false;
            // Request DeviceOrientationEvent permission (primarily for iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const orientationPermission = await DeviceOrientationEvent.requestPermission();
                orientationGranted = orientationPermission === 'granted';
                 console.log("DeviceOrientationEvent permission:", orientationPermission);
            } else {
                console.log("DeviceOrientationEvent.requestPermission not available/needed.");
                orientationGranted = true;
            }

            if (motionGranted && orientationGranted) {
                permissionsGranted = true;
                setStatus('Дозволи надано!', 'success');
                setState('idle'); // Move to idle state, ready to add rooms/track
            } else {
                handlePermissionDenial();
            }
        } catch (error) {
            console.error("Error requesting permissions:", error);
            setStatus(`Помилка запиту дозволів: ${error.message}`, true);
            permissionsGranted = false;
            setState('no_perms'); // Stay in no_perms state
        }
    }

    function handlePermissionDenial() {
        showModal('modal-permissions', false);
        setStatus('Дозволи не надано. Функціональність обмежена.', true);
        permissionsGranted = false;
        setState('no_perms'); // Stay in no_perms state
    }

    // --- Calibration ---
    function showCalibrationIfNeeded() {
        if (needsCalibrationCheck) {
            showModal('modal-calibration', true);
            needsCalibrationCheck = false; // Show only once per session
            return true; // Indicated that calibration was shown
        }
        return false; // Calibration not needed/already done
    }

    function handleCalibrationDone() {
        showModal('modal-calibration', false);
        // Proceed with whatever action required calibration (e.g., start tracking)
        if (state === 'tracking_pending') { // Use a temporary state if needed
             startActualTracking();
         }
    }

    // --- Room Definition ---
    function startRoomDefinition() {
        if (!permissionsGranted) {
             setStatus('Спочатку надайте дозволи на сенсори!', true);
             showModal('modal-permissions');
             return;
         }
        currentRoomDefinition = { name: '', corner1: null, corner2: null };
        inputRoomName.value = ''; // Clear previous name
        showModal('modal-room-name', true);
        setState('defining_room_name');
    }

    function confirmRoomName() {
        const name = inputRoomName.value.trim();
        if (!name) {
            alert("Будь ласка, введіть назву кімнати.");
            return;
        }
        currentRoomDefinition.name = name;
        showModal('modal-room-name', false);
        setState('defining_corner1');
    }

    function setCorner1() {
        // In a real system, we'd record sensor data here.
        // For this prototype, we just mark it as set.
        currentRoomDefinition.corner1 = { x: 0, y: 0 }; // Placeholder coordinates
        console.log("Corner 1 set (symbolic)");
        setState('defining_corner2');
    }

    function setCorner2() {
        // Mark as set. Calculation happens in saveRoom.
        currentRoomDefinition.corner2 = { x: 1, y: 1 }; // Placeholder different from corner1
        console.log("Corner 2 set (symbolic)");
        saveRoomDefinition();
    }

     function saveRoomDefinition() {
         if (!currentRoomDefinition || !currentRoomDefinition.corner1 || !currentRoomDefinition.corner2) {
             console.error("Cannot save room, definition incomplete.");
             cancelRoomDefinition(); // Go back to safety
             return;
         }

         // VERY basic estimation of size. In reality, need step counting
         // between corners or user input. Using default for now.
         const newRoom = {
             id: `room_${Date.now()}`,
             name: currentRoomDefinition.name,
             corners: [currentRoomDefinition.corner1, currentRoomDefinition.corner2],
             // mapRect will be set when placing the room
             mapRect: { x: 0, y: 0, w: DEFAULT_ROOM_SIZE.w, h: DEFAULT_ROOM_SIZE.h },
             color: `hsl(${Math.random() * 360}, 70%, 80%)` // Random light color
         };

         // Don't add to rooms array yet, wait for placement
         console.log("Room definition complete:", newRoom);
         placeRoomNameSpan.textContent = newRoom.name;
         showModal('modal-place-room', true);
         setState('placing_room');
     }


     function handleMapClickForPlacement(event) {
          if (state !== 'placing_room' || !currentRoomDefinition) return;

          const rect = mapCanvas.getBoundingClientRect();
          // Calculate click position relative to canvas origin, considering map panning
          const clickX = event.clientX - rect.left - mapOffset.x;
          const clickY = event.clientY - rect.top - mapOffset.y;

           console.log(`Placing room at map coordinates: (${clickX.toFixed(0)}, ${clickY.toFixed(0)})`);

           // Create the final room object
           const newRoom = {
                id: `room_${Date.now()}`,
                name: currentRoomDefinition.name,
                corners: [currentRoomDefinition.corner1, currentRoomDefinition.corner2], // Keep original corner data if needed
                mapRect: {
                     x: clickX - DEFAULT_ROOM_SIZE.w / 2, // Center the room on click
                     y: clickY - DEFAULT_ROOM_SIZE.h / 2,
                     w: DEFAULT_ROOM_SIZE.w,
                     h: DEFAULT_ROOM_SIZE.h
                 },
                 color: `hsl(${Math.random() * 360}, 60%, 85%)` // Random light color
            };

           rooms.push(newRoom);
           console.log("Room added to map:", newRoom);
           currentRoomDefinition = null; // Clear definition object
           showModal('modal-place-room', false);
           drawMap(); // Redraw map with the new room
           setState('mapping'); // Or 'idle' if preferred after adding
      }


    function cancelRoomDefinition() {
        currentRoomDefinition = null;
        showModal('modal-room-name', false); // Ensure all modals closed
        showModal('modal-place-room', false);
        console.log("Room definition cancelled.");
        setState(rooms.length > 0 ? 'mapping' : 'idle'); // Go back to appropriate state
    }

     function cancelRoomPlacement() {
          // Room definition is complete, but user cancelled placement
          showModal('modal-place-room', false);
          console.log("Room placement cancelled. Definition kept:", currentRoomDefinition);
           // What to do here? Could keep currentRoomDefinition and allow placing later,
           // or discard it. Let's discard for simplicity now.
           currentRoomDefinition = null;
           setState(rooms.length > 0 ? 'mapping' : 'idle');
     }

    // --- Tracking ---
    function startTracking() {
         if (rooms.length === 0) {
              setStatus("Немає кімнат для відстеження. Спочатку додайте кімнату.", true);
              return;
          }

          // If only one room, select it automatically. Otherwise, user needs to select.
          if (rooms.length === 1) {
              setActiveTrackingRoom(rooms[0].id);
               proceedToTracking();
          } else {
              // User must select a room from the list
               setStatus("Виберіть кімнату зі списку праворуч, щоб почати відстеження.", 'info');
               // Highlight the room list or show a specific prompt?
           }
     }

     function setActiveTrackingRoom(roomId) {
          const room = getRoomById(roomId);
          if (!room) {
               console.error(`Cannot set active room: ID ${roomId} not found.`);
               return false;
          }
          activeTrackingRoomId = roomId;
          console.log(`Active tracking room set to: ${room.name} (ID: ${roomId})`);
           // Reset user position relative to the center of the *new* active room
           userPosition.x = room.mapRect.x + room.mapRect.w / 2;
           userPosition.y = room.mapRect.y + room.mapRect.h / 2;
           stepCounter = 0; // Reset step count for the new room
           updateRoomList(); // Update highlighting
           return true;
     }

      function proceedToTracking() {
           if (!activeTrackingRoomId) {
                setStatus("Кімнату для відстеження не вибрано.", true);
                return;
           }

           // Check calibration status
           if (showCalibrationIfNeeded()) {
                setState('tracking_pending'); // Temporary state while calibrating
                return;
           }
            startActualTracking();
      }


     function startActualTracking() {
          console.log("Starting actual tracking process...");
          if (!activeTrackingRoomId) {
               console.error("Cannot start tracking, no active room ID.");
               return; // Should not happen if logic is correct
           }
           setState('tracking');
           startSensors(); // Start sensors
           requestAnimationFrame(gameLoop); // Start the drawing/update loop
           console.log("Tracking loop started.");
     }


    function stopTracking() {
        stopSensors();
        userArrow.style.display = 'none';
         // Keep activeTrackingRoomId for context maybe? Or clear it? Let's keep it for now.
         // activeTrackingRoomId = null;
        setState(rooms.length > 0 ? 'mapping' : 'idle');
        setStatus('Відстеження зупинено.');
         drawMap(); // Redraw map without the arrow potentially moving
    }

    function startSensors() {
        console.log("Attempting to start sensors...");
        try {
            stopSensors(); // Ensure clean start

            // Prefer Generic Sensor API
            if ('Accelerometer' in window && 'AbsoluteOrientationSensor' in window) {
                try {
                    console.log("Using Generic Sensor API.");
                    motionSensor = new Accelerometer({ frequency: SENSOR_FREQUENCY });
                    motionSensor.addEventListener('reading', handleMotion);
                    motionSensor.addEventListener('error', handleSensorError);
                    motionSensor.start();

                    orientationSensor = new AbsoluteOrientationSensor({ frequency: SENSOR_FREQUENCY, referenceFrame: 'screen' });
                    orientationSensor.addEventListener('reading', handleOrientation);
                    orientationSensor.addEventListener('error', handleSensorError);
                    orientationSensor.start();
                    console.log("Generic Sensors started.");
                    return;
                } catch (err) {
                    console.warn("Generic Sensor API failed, falling back.", err.name, err.message);
                }
            }

            // Fallback to older events
            if ('DeviceMotionEvent' in window && 'DeviceOrientationEvent' in window) {
                console.log("Using fallback DeviceMotionEvent/OrientationEvent.");
                window.addEventListener('devicemotion', handleDeviceMotionEvent);
                window.addEventListener('deviceorientation', handleDeviceOrientationEvent);
                 console.log("Fallback listeners added.");
            } else {
                throw new Error("Сенсори руху/орієнтації не підтримуються.");
            }
        } catch (error) {
            console.error("Fatal Sensor start error:", error);
            setStatus(`Помилка запуску сенсорів: ${error.message}`, true);
            setState('error'); // Or back to idle/mapping?
        }
    }

    function stopSensors() {
        console.log("Stopping sensors...");
        if (motionSensor) { motionSensor.stop(); motionSensor = null; }
        if (orientationSensor) { orientationSensor.stop(); orientationSensor = null; }
        window.removeEventListener('devicemotion', handleDeviceMotionEvent);
        window.removeEventListener('deviceorientation', handleDeviceOrientationEvent);
         clearTimeout(stepCooldownTimeout); // Clear any pending cooldown
         stepCooldownTimeout = null;
         console.log("Sensors stopped.");
    }

    function handleSensorError(event) {
        console.error('Sensor Error:', event.error.name, event.error.message);
        // Maybe show a non-fatal error in status bar?
        setStatus(`Помилка сенсора: ${event.error.name}`, true);
    }

    // --- Sensor Data Processing ---
    function handleMotion() { // Generic Sensor
        if (state !== 'tracking' || !motionSensor?.timestamp) return;
        const mag = Math.sqrt(motionSensor.x**2 + motionSensor.y**2 + motionSensor.z**2);
        processStepDetection(mag);
    }
    function handleDeviceMotionEvent(event) { // Fallback
        if (state !== 'tracking') return;
        const acc = event.accelerationIncludingGravity;
        if (!acc?.x) return;
        const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
        processStepDetection(mag);
    }

    function handleOrientation() { // Generic Sensor
        if (state !== 'tracking' || !orientationSensor?.quaternion) return;
        const q = orientationSensor.quaternion;
        const siny_cosp = 2 * (q[3] * q[2] + q[0] * q[1]);
        const cosy_cosp = 1 - 2 * (q[1] * q[1] + q[2] * q[2]);
        let yaw = Math.atan2(siny_cosp, cosy_cosp);
        userOrientation = (yaw * (180 / Math.PI) + 360) % 360;
    }
    function handleDeviceOrientationEvent(event) { // Fallback
        if (state !== 'tracking' || event.alpha === null) return;
        userOrientation = event.alpha; // Use alpha directly, calibration is vital
    }

    function processStepDetection(currentMagnitude) {
        if (stepCooldownTimeout) return;
        const diff = Math.abs(currentMagnitude - (lastAccMagnitude || currentMagnitude));
        if (diff > STEP_THRESHOLD && lastAccMagnitude !== 0) {
            takeStep();
            stepCooldownTimeout = setTimeout(() => { stepCooldownTimeout = null; }, STEP_COOLDOWN);
        }
        lastAccMagnitude = currentMagnitude;
    }

    function takeStep() {
        if (state !== 'tracking' || !activeTrackingRoomId) return;

        stepCounter++;
        const rad = userOrientation * Math.PI / 180;
        const deltaX = Math.sin(rad) * STEP_SIZE_PIXELS;
        const deltaY = -Math.cos(rad) * STEP_SIZE_PIXELS; // Y is inverted in canvas

        userPosition.x += deltaX;
        userPosition.y += deltaY;

        // Boundary check (optional: keep within active room bounds?)
        const room = getRoomById(activeTrackingRoomId);
        if (room) {
             userPosition.x = Math.max(room.mapRect.x, Math.min(room.mapRect.x + room.mapRect.w, userPosition.x));
             userPosition.y = Math.max(room.mapRect.y, Math.min(room.mapRect.y + room.mapRect.h, userPosition.y));
        }

        // Update status bar less frequently?
         setStatus(`Відстеження в кімнаті: ${getRoomById(activeTrackingRoomId)?.name || 'Невідомо'}. Кроків: ${stepCounter}`);
        // Redrawing happens in gameLoop
    }

    // --- Drawing ---
    function gameLoop(timestamp) {
        if (state !== 'tracking') return; // Stop loop if not tracking

        // Update logic could go here if needed based on time

        drawMap(); // Redraw background and rooms
        drawUserArrow(); // Draw the user arrow

        requestAnimationFrame(gameLoop); // Continue the loop
    }

    function drawMap() {
        if (!ctx) return;
        // Clear canvas
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--map-bg').trim();
        ctx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

        // Apply map panning offset
        ctx.save();
        ctx.translate(mapOffset.x, mapOffset.y);

        // Draw all rooms
        rooms.forEach(room => {
            ctx.fillStyle = (room.id === activeTrackingRoomId && state === 'tracking') ?
                            getComputedStyle(document.documentElement).getPropertyValue('--current-room-fill').trim() :
                            room.color; // Use stored color or default fill
            ctx.strokeStyle = (room.id === activeTrackingRoomId && state === 'tracking') ?
                            getComputedStyle(document.documentElement).getPropertyValue('--current-room-border').trim() :
                            getComputedStyle(document.documentElement).getPropertyValue('--room-border').trim();
            ctx.lineWidth = (room.id === activeTrackingRoomId && state === 'tracking') ? 3 : 2;

            ctx.fillRect(room.mapRect.x, room.mapRect.y, room.mapRect.w, room.mapRect.h);
            ctx.strokeRect(room.mapRect.x, room.mapRect.y, room.mapRect.w, room.mapRect.h);

            // Draw room name
            ctx.fillStyle = var(--text-color);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 12px ' + var(--font-main);
            ctx.fillText(room.name, room.mapRect.x + room.mapRect.w / 2, room.mapRect.y + room.mapRect.h / 2);
        });

        // Restore transform
        ctx.restore();
    }

    function drawUserArrow() {
        if (state !== 'tracking' || !activeTrackingRoomId) {
            userArrow.style.display = 'none';
            return;
        }

        // Calculate arrow position relative to the viewport, including map panning
        const arrowScreenX = userPosition.x + mapOffset.x;
        const arrowScreenY = userPosition.y + mapOffset.y;

        // Arrow's own dimensions for centering offset
        const arrowWidth = 18; // Corresponds to border-left + border-right (9+9)
        const arrowHeight = 18; // Corresponds to border-bottom

        userArrow.style.left = `${arrowScreenX - arrowWidth / 2}px`;
        userArrow.style.top = `${arrowScreenY - arrowHeight}px`; // Offset by height to rotate around bottom point
        userArrow.style.transform = `rotate(${userOrientation}deg)`;
        userArrow.style.display = 'block';
    }

    // --- Canvas Resizing ---
    function resizeCanvas() {
         // Make canvas fill the container
         const containerWidth = mainContent.clientWidth;
         const containerHeight = mainContent.clientHeight;
         mapCanvas.width = containerWidth;
         mapCanvas.height = containerHeight;
         console.log(`Canvas resized to ${mapCanvas.width}x${mapCanvas.height}`);
         // Redraw map after resize
         drawMap();
         if (state === 'tracking') {
             drawUserArrow(); // Reposition arrow if tracking
         }
     }

    // --- Map Interaction ---
    function handlePanStart(event) {
        if (state === 'placing_room') return; // Don't pan while placing
        isPanning = true;
        panStart.x = event.clientX - mapOffset.x;
        panStart.y = event.clientY - mapOffset.y;
        mapCanvas.classList.add('grabbing');
    }

    function handlePanMove(event) {
        if (!isPanning) return;
        mapOffset.x = event.clientX - panStart.x;
        mapOffset.y = event.clientY - panStart.y;
        // Redraw needed while panning
        drawMap();
         if (state === 'tracking') drawUserArrow(); // Keep arrow updated
    }

    function handlePanEnd() {
        if (isPanning) {
            isPanning = false;
            mapCanvas.classList.remove('grabbing');
        }
    }

     // --- Room List ---
     function updateRoomList() {
          roomListUl.innerHTML = ''; // Clear existing list
          rooms.forEach(room => {
               const li = document.createElement('li');
               li.textContent = room.name;
               li.dataset.roomId = room.id; // Store room ID for click handling
               if (room.id === activeTrackingRoomId) {
                    li.classList.add('active-tracking-room');
               }
               roomListUl.appendChild(li);
          });
     }

      function handleRoomListClick(event) {
           if (event.target.tagName === 'LI' && event.target.dataset.roomId) {
                const roomId = event.target.dataset.roomId;
                if (state === 'tracking') {
                     // Allow switching rooms while tracking? Could be complex.
                     // For now, let's require stopping first.
                     setStatus(`Щоб змінити кімнату, зупиніть відстеження.`, 'info');
                 } else {
                     // Set as the room to start tracking in next time
                      if (setActiveTrackingRoom(roomId)) {
                          setStatus(`Наступне відстеження почнеться в кімнаті: ${getRoomById(roomId)?.name}. Натисніть 'Відстеження'.`, 'success');
                           // Optionally pan map to center this room?
                      }
                 }
            }
       }

       function getRoomById(id) {
            return rooms.find(room => room.id === id);
       }


    // --- Start App ---
    document.addEventListener('DOMContentLoaded', init);

</script>

</body>
</html>
