<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Інтерактивна Карта Поверху</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <style>
        /* Basic Reset & Body Styling */
        html {
            box-sizing: border-box;
            height: 100%;
        }
        *, *:before, *:after {
            box-sizing: inherit;
        }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #f0f0f0; /* Background for areas outside map */
            overscroll-behavior: none; /* Prevent pull-to-refresh actions */
            position: fixed; /* Prevent scrolling on iOS */
        }

        /* Map Container - Handles centering and positioning */
        #map-container {
            position: relative; /* Crucial for absolute positioning of children */
            width: 100%;
            height: 100%;
            display: flex; /* Use flexbox for centering */
            justify-content: center;
            align-items: center;
            background-color: #ffffff; /* Map background */
        }

        /* Map Image - Scales responsively */
        #map-image {
            display: block; /* Remove extra space below image */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* Scale while preserving aspect ratio */
            user-select: none; /* Prevent image selection */
            -webkit-user-drag: none; /* Prevent image dragging */
            box-shadow: 0 0 15px rgba(0,0,0,0.2); /* Subtle shadow for depth */
            background-color: #e0e0e0; /* Placeholder bg while loading */
        }

        /* Arrow Indicator */
        #arrow {
            position: absolute;
            /* Start hidden until position is known and permission granted */
            visibility: hidden;
            width: 0;
            height: 0;
            /* Create triangle shape */
            border-left: 11px solid transparent;    /* Half base width */
            border-right: 11px solid transparent;   /* Half base width */
            border-bottom: 22px solid rgba(220, 30, 30, 0.9); /* Red arrow */
            /* Set rotation point to the bottom center (tip of the arrow) */
            transform-origin: 50% 100%;
            /* Smooth transitions */
            transition: transform 0.18s linear, /* Faster rotation updates */
                        top 0.4s ease-out,
                        left 0.4s ease-out,
                        visibility 0s linear 0.1s;
            z-index: 10; /* Ensure arrow is above map and labels */
            /* Initial position set by JS */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -100%) rotate(0deg); /* Centered horizontally, tip at the point */
            pointer-events: none; /* Don't interfere */
            filter: drop-shadow(0px 1px 2px rgba(0,0,0,0.4)); /* Arrow shadow */
        }

        /* Room Labels */
        .room-label {
            position: absolute;
            background-color: rgba(0, 60, 130, 0.8); /* Darker blue background */
            color: white;
            padding: 4px 8px; /* Slightly larger padding */
            border-radius: 5px;
            font-size: 10px; /* Base font size */
            font-weight: bold;
            white-space: nowrap; /* Prevent wrapping */
            /* Center the label on its coordinates */
            transform: translate(-50%, -50%) scale(1.0);
            transform-origin: center center; /* Scale from center */
            /* Smooth transition for scaling and color */
            transition: transform 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275), /* Elastic scale */
                        background-color 0.3s ease-in-out,
                        opacity 0.5s ease,
                        left 0s, /* No transition for position */
                        top 0s;
            z-index: 5; /* Below arrow, above map */
            pointer-events: none; /* Don't interfere with map interaction */
            opacity: 0; /* Start hidden until positioned */
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            text-align: center;
        }

        /* Highlighted State for Room Labels */
        .room-label.highlighted {
            transform: translate(-50%, -50%) scale(1.9); /* Scale up more */
            background-color: rgba(210, 40, 40, 0.92); /* Brighter Red when highlighted */
            z-index: 6; /* Bring slightly forward */
        }

        /* Modal for Permissions */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1000; /* Above everything */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 320px;
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.25);
            text-align: center;
            border-top: 5px solid #007bff;
        }

        .modal p {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
            color: #333;
        }

        .modal button {
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.2s ease, transform 0.1s ease;
            appearance: none; /* Remove default styles */
        }
        .modal button:hover, .modal button:focus {
            background-color: #0056b3;
            outline: none;
        }
         .modal button:active {
             transform: scale(0.98);
         }

        /* Debug Output */
        #debug {
            position: fixed;
            bottom: 5px;
            left: 5px;
            background: rgba(0,0,0,0.65);
            color: white;
            padding: 5px 10px;
            font-size: 10px;
            border-radius: 4px;
            z-index: 101;
            max-width: calc(100% - 10px);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            opacity: 0.9;
        }

        /* Loading indicator (optional) */
        #loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001; /* Above modal */
            font-size: 18px;
            color: #555;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            display: none; /* Hidden by default */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="map-container">
        <!-- Використовуємо пряме посилання на зображення, надане вами -->
        <img id="map-image"
             src="https://i.ibb.co/63wnkPW/test.png"
             alt="План поверху"
             onerror="this.alt='Помилка завантаження карти'; console.error('Failed to load map image from: ' + this.src);"
        >

        <div id="arrow"></div>

        <!-- ======================================================================== -->
        <!-- === УВАГА! НАЛАШТУЙТЕ ЦІ КООРДИНАТИ ДЛЯ ВАШОЇ КАРТИ! === -->
        <!-- === data-x = % від лівого краю; data-y = % від верхнього краю === -->
        <!-- ======================================================================== -->
        <div class="room-label" id="label-K201" data-room-id="K201 Їдальня" data-x="45" data-y="65">K201</div>
        <div class="room-label" id="label-K202" data-room-id="K202" data-x="18" data-y="25">K202</div>
        <div class="room-label" id="label-K203" data-room-id="K203" data-x="17" data-y="10">K203</div>
        <div class="room-label" id="label-K204" data-room-id="K204" data-x="26" data-y="10">K204</div>
        <div class="room-label" id="label-K205" data-room-id="K205" data-x="35" data-y="10">K205</div>
        <div class="room-label" id="label-K206" data-room-id="K206" data-x="44" data-y="10">K206</div>
        <div class="room-label" id="label-K207" data-room-id="K207" data-x="53" data-y="10">K207</div>
        <div class="room-label" id="label-K208" data-room-id="K208" data-x="75" data-y="15">K208</div>
        <div class="room-label" id="label-WC-M" data-room-id="K209 WC Чоловічий" data-x="70" data-y="38">WC Чол.</div>
        <div class="room-label" id="label-WC-F" data-room-id="K210 WC Жіночий" data-x="70" data-y="48">WC Жін.</div>
        <div class="room-label" id="label-WC-A" data-room-id="WC Доступний" data-x="60" data-y="40">WC Дост.</div>
        <div class="room-label" id="label-K214" data-room-id="K214" data-x="70" data-y="65">K214</div>
        <div class="room-label" id="label-K215" data-room-id="K215" data-x="65" data-y="75">K215</div>
        <div class="room-label" id="label-K217" data-room-id="K217" data-x="60" data-y="70">K217</div>
        <div class="room-label" id="label-K2" data-room-id="K2 Тех. прим." data-x="60" data-y="48">K2</div>
        <div class="room-label" id="label-K21a" data-room-id="K21 Тех. прим. (верх)" data-x="60" data-y="43">K21</div>
        <div class="room-label" id="label-K21b" data-room-id="K21 Тех. прим. (низ)" data-x="65" data-y="70">K21</div>
        <div class="room-label" id="label-Exit-F" data-room-id="Вихід F" data-x="88" data-y="80">Вихід F</div>
        <div class="room-label" id="label-Exit-G" data-room-id="Вихід G" data-x="88" data-y="30">Вихід G</div>
        <div class="room-label" id="label-Exit-D" data-room-id="Вхід D" data-x="50" data-y="97">Вхід D</div>
        <div class="room-label" id="label-Stairs" data-room-id="Сходи" data-x="40" data-y="30">Сходи</div>
         <!-- ======================================================================== -->
         <!-- === КІНЕЦЬ БЛОКУ КООРДИНАТ КІМНАТ === -->
         <!-- ======================================================================== -->
    </div>

    <div id="debug">Ініціалізація...</div> <!-- For debugging -->

    <div id="permission-prompt" class="modal">
        <p>Щоб показувати ваш напрямок на карті, потрібен доступ до датчиків орієнтації вашого пристрою.</p>
        <button id="grant-permission">Надати доступ</button>
    </div>

     <div id="loading-indicator">Завантаження карти...</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mapContainer = document.getElementById('map-container');
            const mapImage = document.getElementById('map-image');
            const arrow = document.getElementById('arrow');
            const roomLabelElements = document.querySelectorAll('.room-label');
            const debugInfo = document.getElementById('debug');
            const permissionPrompt = document.getElementById('permission-prompt');
            const grantButton = document.getElementById('grant-permission');
            const loadingIndicator = document.getElementById('loading-indicator');

            // --- State Variables ---
            let currentOrientation = 0; // Device heading (0-360 degrees, 0 = North)
            let compassOffset = 0; // Manual offset if map North != true North
            let orientationPermissionGranted = false;
            let orientationFallbackUsed = false; // Flag if using relative orientation

            // === SIMULATED POSITION ===
            // !! IMPORTANT: This is NOT real-time tracking inside the building !!
            // Start user near entrance D (adjust if needed)
            let currentUserPosition = { xPercent: 50, yPercent: 95 }; // % of map container
            const proximityThresholdPercent = 6; // % of map's smaller dimension

            let mapLoaded = false;
            let mapRect = null; // Cached map dimensions and position

            // --- Room Data ---
            const rooms = [];
            roomLabelElements.forEach(label => {
                const x = parseFloat(label.dataset.x);
                const y = parseFloat(label.dataset.y);
                // Basic validation of coordinates from HTML
                if (!isNaN(x) && x >= 0 && x <= 100 && !isNaN(y) && y >= 0 && y <= 100) {
                    rooms.push({
                        id: label.dataset.roomId || label.id, // Use data-room-id preferably
                        element: label,
                        xPercent: x,
                        yPercent: y,
                    });
                } else {
                    console.warn(`Invalid or missing coordinates for room label: ${label.id}. Check data-x and data-y attributes.`);
                    // Optionally hide or style invalid labels differently
                    label.style.display = 'none';
                }
            });
             console.log(`Initialized ${rooms.length} rooms with valid coordinates.`);

            // --- Utility Functions ---
            // Debounce function to limit frequent event triggers
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // --- Map & Element Positioning ---
            function updateMapAndElementPositions() {
                 // Check if image has loaded and has dimensions
                if (!mapImage.complete || mapImage.naturalWidth === 0) {
                    console.log("Map image not ready for positioning.");
                     // Ensure loading indicator is shown if map isn't ready
                    if (getComputedStyle(loadingIndicator).display === 'none') {
                         loadingIndicator.style.display = 'block';
                    }
                    // Try again shortly - useful for race conditions on load
                    // setTimeout(updateMapAndElementPositions, 100);
                    return;
                }
                 // Hide loading indicator once map is ready
                 if (loadingIndicator.style.display !== 'none') {
                    loadingIndicator.style.display = 'none';
                 }


                mapRect = mapImage.getBoundingClientRect(); // Get current rendered size/pos
                if (!mapRect || mapRect.width === 0 || mapRect.height === 0) {
                    console.error("Map dimensions are zero, cannot position elements. BoundingRect:", mapRect);
                     // Try again in case layout wasn't finished
                     requestAnimationFrame(updateMapAndElementPositions);
                    return;
                }

                // Position labels based on mapRect and their percentage data
                rooms.forEach(room => {
                    const labelX = mapRect.left + (mapRect.width * room.xPercent / 100);
                    const labelY = mapRect.top + (mapRect.height * room.yPercent / 100);
                    room.element.style.left = `${labelX}px`;
                    room.element.style.top = `${labelY}px`;
                    // Fade in labels after positioning
                    requestAnimationFrame(() => {
                         room.element.style.opacity = '1';
                    });
                });

                // Only set mapLoaded true once everything is positioned
                if (!mapLoaded) {
                    mapLoaded = true;
                    console.log("Map and labels positioned successfully.");
                    updateArrowPosition(); // Update arrow position now map is sized
                    updateRoomHighlighting(); // Initial highlight check
                }
                updateDebugInfo(); // Update debug display
            }

            const debouncedUpdatePositions = debounce(updateMapAndElementPositions, 150);

            // --- Event Listeners Setup ---
            // Image loading successful
            mapImage.onload = () => {
                console.log("Map image loaded successfully (onload event).");
                updateMapAndElementPositions();
            };
             // Image loading error
             mapImage.onerror = () => {
                 console.error("ERROR loading map image from:", mapImage.src);
                 loadingIndicator.textContent = "Помилка завантаження карти!";
                 loadingIndicator.style.display = 'block'; // Ensure indicator shows error
                 // Optionally hide the broken image element
                 mapImage.style.display = 'none';
             };

            // Initial check if image is already cached and loaded
            if (mapImage.complete && mapImage.naturalWidth > 0) {
                console.log("Map image was already complete (cached). Running initial positioning.");
                // Use requestAnimationFrame for better timing with rendering engine
                requestAnimationFrame(updateMapAndElementPositions);
            } else if (!mapImage.complete) {
                console.log("Map image not yet complete. Waiting for onload or onerror...");
                loadingIndicator.style.display = 'block'; // Show loading indicator
            } else {
                 // Complete but no width likely means error state already handled by onerror,
                 // or it's a 0x0 image.
                 console.warn("Map image reported complete but has zero natural width.");
                 if (!mapImage.onerror) { // If onerror didn't fire for some reason
                      loadingIndicator.textContent = "Помилка: Не вдалося отримати розміри карти.";
                      loadingIndicator.style.display = 'block';
                 }
            }


            // Window resize and orientation change
            window.addEventListener('resize', debouncedUpdatePositions);
            window.addEventListener('orientationchange', debouncedUpdatePositions);

            // Permission button
            grantButton.addEventListener('click', requestOrientationPermission);

            // --- Permission Handling ---
            function requestOrientationPermission() {
                permissionPrompt.style.display = 'none'; // Hide prompt

                // 1. iOS / iPadOS specific permission request
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    console.log("Requesting iOS orientation permission...");
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            console.log("iOS Permission state:", permissionState);
                            if (permissionState === 'granted') {
                                orientationPermissionGranted = true;
                                addOrientationListeners();
                                // Delay showing arrow slightly until first orientation event?
                                // arrow.style.visibility = 'visible';
                                updateDebugInfo();
                            } else {
                                orientationPermissionGranted = false;
                                alert('Доступ до орієнтації відхилено. Стрілка напрямку не працюватиме.');
                                updateDebugInfo("Доступ до орієнтації відхилено");
                            }
                        })
                        .catch(error => {
                            console.error("Error requesting iOS orientation permission:", error);
                            orientationPermissionGranted = false;
                            alert('Сталася помилка при запиті доступу до орієнтації.');
                            updateDebugInfo("Помилка запиту доступу");
                        });
                } else {
                    // 2. Standard approach (Android, other non-iOS browsers)
                    console.log("Adding standard orientation listeners (non-iOS/iPadOS).");
                    // We assume permission is implicitly granted or not needed to ask for non-iOS.
                    // The browser might still block it silently if permissions were denied previously.
                    orientationPermissionGranted = true;
                    addOrientationListeners();
                    // arrow.style.visibility = 'visible'; // Delay showing arrow slightly?
                    updateDebugInfo();
                }
            }

            function addOrientationListeners() {
                if (!window.DeviceOrientationEvent) {
                     console.error("DeviceOrientationEvent not supported by this browser.");
                     updateDebugInfo("Подія DeviceOrientation не підтримується");
                     orientationPermissionGranted = false;
                     return;
                }
                console.log("Adding orientation event listeners...");
                // Add listeners with 'true' for capture phase might sometimes help, but default is usually fine.
                window.addEventListener('deviceorientationabsolute', handleOrientation);
                window.addEventListener('deviceorientation', handleOrientationFallback);
            }

            // Initial check: Determine if we need to prompt the user (iOS) or can just try (Android)
            function initializeOrientationCheck() {
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS: Must prompt on user interaction. Show the modal.
                     permissionPrompt.style.display = 'block';
                     updateDebugInfo("Очікування дозволу...");
                } else if (typeof DeviceOrientationEvent !== 'undefined') {
                    // Android/Other: Try to add listeners directly. No modal needed initially.
                     console.log("Attempting to initialize orientation directly (non-iOS path).")
                     requestOrientationPermission();
                } else {
                    // No support at all
                    alert("На жаль, датчики орієнтації не підтримуються цим пристроєм або браузером.");
                    updateDebugInfo("Датчики орієнтації недоступні");
                    orientationPermissionGranted = false;
                }
            }


            // --- Sensor Event Handlers ---
            let firstOrientationUpdate = true;
            function handleOrientation(event) {
                if (!orientationPermissionGranted) return;
                // Prefer absolute orientation (compass)
                if (event.absolute === true && typeof event.alpha === 'number') {
                    processOrientationData(event.alpha);
                    if (orientationFallbackUsed) {
                         console.log("Switched back to deviceorientationabsolute");
                         orientationFallbackUsed = false;
                    }
                } else if (!orientationFallbackUsed) {
                     // Let fallback handle it if absolute isn't working reliably
                }
            }

            function handleOrientationFallback(event) {
                 if (!orientationPermissionGranted) return;
                // Use relative orientation only if absolute isn't firing or isn't absolute
                const absoluteSupported = 'absolute' in event;
                if (typeof event.alpha === 'number' && (!absoluteSupported || !event.absolute)) {
                    if (!orientationFallbackUsed) {
                        console.warn("Using fallback 'deviceorientation'. May be relative to start orientation.");
                        orientationFallbackUsed = true;
                    }
                    // Check for webkitCompassHeading (older Safari)
                    const heading = event.webkitCompassHeading !== undefined ? event.webkitCompassHeading : event.alpha;
                     if (typeof heading === 'number') {
                         processOrientationData(heading);
                     } else {
                          // Avoid logging repeatedly if fallback value is consistently bad
                          if (orientationFallbackUsed) console.warn("Fallback orientation alpha/heading is not a number.");
                     }
                }
            }

            function processOrientationData(alpha) {
                let heading = alpha;

                // Simple screen orientation adjustment (might need refinement for edge cases)
                const screenOrientation = window.orientation || (screen.orientation ? screen.orientation.angle : 0) || 0;
                // Adjust heading based on landscape mode if needed
                if (Math.abs(screenOrientation) === 90) {
                     heading = (heading + screenOrientation + 360) % 360;
                }

                // Apply manual offset and ensure value is 0-360
                currentOrientation = (heading + compassOffset + 360) % 360;

                 // Make arrow visible only after the first valid orientation reading
                 if (firstOrientationUpdate && arrow.style.visibility !== 'visible') {
                     arrow.style.visibility = 'visible';
                     firstOrientationUpdate = false;
                     console.log("First orientation update received, showing arrow.");
                 }


                updateArrowRotation(); // Update visual rotation
                updateDebugInfo();     // Update status text
            }

            // --- UI Update Functions ---
            function updateArrowRotation() {
                // Update happens in processOrientationData after calculation now
                 if (!mapLoaded || !orientationPermissionGranted || firstOrientationUpdate) return; // Don't rotate if not ready or hidden
                 arrow.style.transform = `translate(-50%, -100%) rotate(${currentOrientation}deg)`;
            }

            function updateArrowPosition() {
                if (!mapLoaded || !mapRect) return; // Check mapRect too
                const arrowX = mapRect.left + (mapRect.width * currentUserPosition.xPercent / 100);
                const arrowY = mapRect.top + (mapRect.height * currentUserPosition.yPercent / 100);
                arrow.style.left = `${arrowX}px`;
                arrow.style.top = `${arrowY}px`;
            }

            function updateRoomHighlighting() {
                if (!mapLoaded || !mapRect) return;

                const smallerDim = Math.min(mapRect.width, mapRect.height);
                if (smallerDim <= 0) return; // Avoid division by zero or negative thresholds

                const thresholdPixels = smallerDim * proximityThresholdPercent / 100;
                const thresholdSq = thresholdPixels * thresholdPixels;

                const userPixelX = mapRect.width * currentUserPosition.xPercent / 100;
                const userPixelY = mapRect.height * currentUserPosition.yPercent / 100;

                let closestRoom = null;
                let minDistanceSq = Infinity;

                rooms.forEach(room => {
                    const roomPixelX = mapRect.width * room.xPercent / 100;
                    const roomPixelY = mapRect.height * room.yPercent / 100;

                    const dx = userPixelX - roomPixelX;
                    const dy = userPixelY - roomPixelY;
                    const distanceSq = (dx * dx) + (dy * dy);

                    if (distanceSq < thresholdSq && distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                        closestRoom = room;
                    }
                    // Remove highlight from all rooms efficiently
                    if (room.element.classList.contains('highlighted')) {
                         room.element.classList.remove('highlighted');
                    }
                });

                // Highlight only the single closest room within the threshold
                if (closestRoom) {
                    closestRoom.element.classList.add('highlighted');
                }
            }

            function updateDebugInfo(overrideMessage = null) {
                if (overrideMessage) {
                    debugInfo.textContent = overrideMessage;
                    return;
                }
                 let status = "";
                 if (!mapLoaded) {
                     status = "Завантаження...";
                 } else {
                     status = `Поз (симуляція): ${currentUserPosition.xPercent.toFixed(0)}%, ${currentUserPosition.yPercent.toFixed(0)}%`;
                     if (orientationPermissionGranted) {
                         status += ` | Орієнт: ${currentOrientation.toFixed(0)}° ${orientationFallbackUsed ? '(Відносн.)' : '(Абсолют.)'}`;
                     } else {
                         status += " | Орієнт: Немає доступу";
                     }
                 }
                 debugInfo.textContent = status;
            }

            // --- Keyboard Controls for Simulation (Desktop Testing) ---
            document.addEventListener('keydown', (e) => {
                if (!mapLoaded) return; // Don't allow control if map isn't ready

                const step = 1.5; // Percentage step for movement
                const rotStep = 5; // Degrees step for rotation
                let moved = false;
                let rotated = false;

                 // Check if focus is on an input element, if any existed - ignore keys then
                 // if (document.activeElement && document.activeElement.tagName === 'INPUT') return;

                switch (e.key) {
                    // Movement (WASD + Arrows)
                    case 'ArrowUp':    case 'w': case 'W': case 'ö': case 'Ö': currentUserPosition.yPercent -= step; moved = true; break; // Added ö/Ö for ukrainian layout Ц
                    case 'ArrowDown':  case 's': case 'S': case 'і': case 'І': currentUserPosition.yPercent += step; moved = true; break; // Added і/І for ukrainian layout І
                    case 'ArrowLeft':  case 'a': case 'A': case 'ô': case 'Ô': currentUserPosition.xPercent -= step; moved = true; break; // Added ô/Ô for ukrainian layout Ф
                    case 'ArrowRight': case 'd': case 'D': case 'â': case 'Â': currentUserPosition.xPercent += step; moved = true; break; // Added â/Â for ukrainian layout В

                    // Rotation Simulation (Comma/Period or Q/E)
                    case ',': case '<': case 'q': case 'Q': case 'é': case 'É': currentOrientation = (currentOrientation - rotStep + 360) % 360; rotated = true; break; // Added é/É for ukrainian layout Й
                    case '.': case '>': case 'e': case 'E': case 'ó': case 'Ó': currentOrientation = (currentOrientation + rotStep) % 360; rotated = true; break; // Added ó/Ó for ukrainian layout У
                }


                if (moved) {
                    // Clamp position to map bounds (0-100%)
                    currentUserPosition.xPercent = Math.max(0, Math.min(100, currentUserPosition.xPercent));
                    currentUserPosition.yPercent = Math.max(0, Math.min(100, currentUserPosition.yPercent));
                    updateArrowPosition();
                    updateRoomHighlighting();
                }
                 // Update rotation only if orientation sensors are NOT active/granted
                 // OR if specifically triggered by rotation keys
                if (rotated && !orientationPermissionGranted) { // Allow keyboard rotation override only if sensors off
                    updateArrowRotation();
                } else if (rotated && orientationPermissionGranted){
                     // If sensors are ON, keyboard rotation only updates the debug value,
                     // the actual arrow follows the sensor. Could potentially add an override toggle?
                     console.log("Keyboard rotation attempted while sensors active - ignored for arrow display.");
                }

                if (moved || rotated) {
                    updateDebugInfo(); // Update debug after any change
                }
            });

            // --- Initial Setup Calls ---
            updateDebugInfo(); // Initial debug message
            initializeOrientationCheck(); // Start permission check/setup process

        }); // End DOMContentLoaded
    </script>
</body>
</html>
